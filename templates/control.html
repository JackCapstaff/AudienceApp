<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>üéõÔ∏è Control Panel</title>
  <!-- Socket.IO -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.3.2/socket.io.min.js" crossorigin="anonymous"></script>
  <!-- SortableJS for drag-and-drop queue -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
  <!-- PapaParse for CSV import -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.1/papaparse.min.js"></script>
  <style>
    body { font-family: sans-serif; padding:1rem; }
    h1 { margin-top: 0; }
    #top-controls button { margin-right:0.5rem; padding:0.5rem 1rem; }
    #asset-grid, #queue, #transition-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px,1fr));
      gap:0.5rem;
      margin: 0.5rem 0; border:1px solid #ccc; padding:0.5rem; min-height: 120px;
    }
    .asset-tile, .queue-tile, .transition-tile {
      position: relative; cursor: grab; border:2px solid transparent;
      border-radius:6px; overflow:hidden; background:#111;
      user-select: none;
    }
    .queue-tile.current { border-color:#007BFF; }
    .asset-tile img, .asset-tile video, .queue-tile img, .queue-tile video {
      width:100%; height:auto; object-fit:contain;
      pointer-events: none;
    }
    .tile-label {
      position:absolute; bottom:2px; left:2px;
      background:rgba(0,0,0,0.6); color:white;
      padding:1px 4px; font-size:0.75rem;
    }
    #send-options, #queue-controls { margin:0.5rem 0; }
    #send-options label, #queue-controls button { margin-right:0.5rem; }
    #preview-container, #current-audience-container {
      border: 1px solid #ccc; padding: 0.5rem; margin-bottom: 0.5rem;
      width: 48%; box-sizing: border-box;
    }
    #preview-area {
      display: flex; justify-content: space-between; width: 100%;
    }
    #current-audience-img, #current-audience-video, #preview-img, #preview-video {
      max-width: 100%; display: none;
    }
    #media-controls { margin-top: 1rem; }
    #media-scrubber { width: 220px; vertical-align: middle; }
    #media-time { font-family: monospace; margin-left: 0.4em; }
    .transition-label { font-weight:bold; letter-spacing: 1px; }
    #transition-box { border:2px dashed #888; margin-bottom:1rem; background:#222; padding:0.5rem; }
    #transition-box h3 { margin:0 0 0.3em 0; color:#ccc; font-size:1.1em;}

    .queue-tile .remove-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      background: rgba(255, 40, 40, 0.9);
      color: #fff;
      border: none;
      border-radius: 50%;
      font-size: 1.1em;
      width: 22px;
      height: 22px;
      line-height: 18px;
      cursor: pointer;
      display: none;
      z-index: 2;
      transition: background 0.2s;
    }
    .queue-tile:hover .remove-btn {
      display: block;
    }
    .queue-tile .remove-btn:hover {
      background: #b30000;
    }
    .queue-tile .autoplay-toggle {
      position: absolute;
      top: 2px;
      left: 2px;
      background: rgba(0,150,255,0.85);
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 0.85em;
      padding: 1px 6px;
      cursor: pointer;
      display: none;
      z-index: 2;
      transition: background 0.2s;
    }
    .queue-tile:hover .autoplay-toggle {
      display: block;
    }
    .queue-tile .autoplay-toggle.on {
      background: #34c759;
    }
  </style>
</head>
<body>
  <header>
    <nav>   
      <a href="{{ url_for('logout') }}" class="logout-button">Logout</a>
    </nav>

    <div id="active-viewer-count" style="padding:0.5rem; margin-top:0.5rem; font-weight:bold;">
    Active viewers: <span id="viewer-count">0</span>
    </div>
  </header>
  <h1>üéõÔ∏è Control Panel</h1>
  <div id="top-controls">
    <button id="black-button">Go to Black Screen</button>
    <button id="placeholder-button">Go to Placeholder</button>
    
  </div>

  <div id="crossfade-settings" style="margin:0.5em 0;">
    <label>Crossfade Duration:
      <input type="number" id="crossfade-duration" min="0.2" max="10" step="0.1" value="2.0" style="width:4em;">
      seconds
    </label>
    <label>Fade-to-Black Duration:
      <input type="number" id="fade-black-duration" min="0.2" max="10" step="0.1" value="0.8" style="width:4em;">
      seconds
    </label>

  </div>

  <h2>Asset Library (drag into queue)</h2>
  <div id="asset-grid">
    {% for slide in slides %}
      <div class="asset-tile" draggable="true" data-type="slide" data-name="{{ slide }}">
        <img src="/static/slides/{{ slide }}" alt="{{ slide }}"/>
        <div class="tile-label">{{ slide }}</div>
      </div>
    {% endfor %}
    {% for vid in videos %}
      <div class="asset-tile" draggable="true" data-type="video" data-name="{{ vid }}">
        <video muted>
          <source src="/static/media/{{ vid }}" type="video/mp4">
        </video>
        <div class="tile-label">{{ vid }}</div>
      </div>
    {% endfor %}
  </div>

  <div id="transition-box">
    <h3>Transitions &amp; Cues (drag to queue):</h3>
    <div id="transition-grid">
      <div class="transition-tile" draggable="true" data-type="transition" data-name="fade_to_black">
        <div style="background:#000;width:100%;height:60px;display:flex;align-items:center;justify-content:center;">
          <span class="transition-label" style="color:white;">Fade to Black</span>
        </div>
      </div>
      <div class="transition-tile" draggable="true" data-type="transition" data-name="fade_from_black">
        <div style="background:#444;width:100%;height:60px;display:flex;align-items:center;justify-content:center;">
          <span class="transition-label" style="color:white;">Fade from Black</span>
        </div>
      </div>
      <div class="transition-tile" draggable="true" data-type="transition" data-name="crossfade">
        <div style="background:linear-gradient(90deg,#111,#fff,#111);width:100%;height:60px;display:flex;align-items:center;justify-content:center;">
          <span class="transition-label" style="color:black;">Crossfade</span>
        </div>
      
      </div>
    </div>
  </div>

  <h2>Queue</h2>
  <div id="queue"></div>
  <div id="queue-controls">
    <button onclick="prevInQueue()">‚Üê Prev in Queue</button>
    <button onclick="nextInQueue()">Next in Queue ‚Üí</button>
    <button onclick="sendCurrent()">Send Current</button>
  </div>

  <div id="send-options">
    <label><input type="checkbox" id="fadeout-checkbox"/> Fade Out to Black</label>
    <label><input type="checkbox" id="fadein-checkbox"/> Fade In from Black</label>
    <label><input type="checkbox" id="autoplay-checkbox"/> Autoplay videos</label>
    
  </div>

  <div id="queue-presets">
    
    <label style="margin-left:1rem;">
      Import Queue CSV:
      <input type="file" id="import-csv" accept=".csv">
    </label>
    <label style="margin-left:1rem;">
      Export Queue CSV:
      <input type="file" id="export-csv-button" accept=".csv">
    </label>
   
  </div>

  <div id="media-controls">
    <button id="play-pause-button">Play/Pause</button>
    <label for="playback-speed">Playback Speed:</label>
    <input type="number" id="playback-speed" min="0.25" max="2.0" step="0.25" value="1.0">
    <input type="range" id="media-scrubber" min="0" max="100" step="0.1" value="0">
    <span id="media-time">00:00 / 00:00</span>
  </div>

  <div id="current-audience-container">
    <h2>Current Audience View</h2>
    <iframe
      src="/"
      id="audience-iframe"
      style="width:100%;height:320px;border:1px solid #ccc;background:black;border-radius:6px;"
      title="Audience Live View"
      allowfullscreen
    ></iframe>
  </div>
    <div id="preview-container">
      <h2>Preview</h2>
      <img id="preview-img" alt="Slide preview"/>
      <video id="preview-video" controls>
        <source id="preview-source" src="" type="video/mp4">
      </video>
    </div>
  </div>

   <script>
    const socket = io({ transports: ['websocket'], upgrade: false, secure: true });

    // Black & Placeholder
    document.getElementById('black-button').onclick = () => {
      // Get duration (could add an input for this)
      const dur = parseFloat(document.getElementById('fade-black-duration')?.value) || 0.8;
      socket.emit('fade_to_black', { duration: dur });
    };

    document.getElementById('placeholder-button').onclick = () => socket.emit('display_asset', { type: 'slide', name: 'holdingslide.jpg', autoplay: false, fadeIn: false });

    // --- Drag/Drop assets & transitions ---
    const assetTiles = document.querySelectorAll('.asset-tile');
    const transitionTiles = document.querySelectorAll('.transition-tile');
    const queueEl = document.getElementById('queue');
    let queue = [], currentIdx = -1;
    // Preview elements
    const previewImg = document.getElementById('preview-img');
    const previewVid = document.getElementById('preview-video');
    const previewSrc = document.getElementById('preview-source');

    function handleTileDragStart(tile) {
      tile.addEventListener('dragstart', e => {
        e.dataTransfer.setData('text/plain', JSON.stringify({ type: tile.dataset.type, name: tile.dataset.name }));
      });
      tile.addEventListener('dblclick', () => {
        queue.push({ type: tile.dataset.type, name: tile.dataset.name });
        renderQueue();
      });
    }
    assetTiles.forEach(handleTileDragStart);
    transitionTiles.forEach(handleTileDragStart);

    queueEl.addEventListener('dragover', e => e.preventDefault());
    queueEl.addEventListener('drop', e => {
      e.preventDefault();
      const data = JSON.parse(e.dataTransfer.getData('text/plain'));
      queue.push(data);
      renderQueue();
    });

    // CSV import listener
    document.getElementById('import-csv').addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;

      // 1. If queue already has items, prompt the user
      if (queue.length > 0) {
        // 2. Show warning and ask if they want to save, proceed, or cancel
        const msg = "‚ö†Ô∏è Importing will overwrite your current queue.\n\nDo you want to export (save) the current queue before importing?\n\nPress OK to save and continue, Cancel to show more options.";
        if (confirm(msg)) {
          // Export current queue first
          document.getElementById('export-csv-button').click();
          // Then proceed after export
          setTimeout(() => doImport(file), 500); // Give the save dialog a moment
        } else {
          // Offer choice: Proceed without saving, or cancel
          const proceed = confirm("Are you sure you want to overwrite the current queue?\n\nPress OK to continue and overwrite, or Cancel to abort import.");
          if (proceed) {
            doImport(file);
          } else {
            // Cancelled
            e.target.value = ""; // Reset file input so it can be reused
            alert("Import cancelled. Your queue was not changed.");
          }
        }
      } else {
        // If queue is empty, just import
        doImport(file);
      }
    });

    // Import helper function
    function doImport(file) {
      queue.length = 0; // Clear the queue
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: results => {
          results.data.forEach(row => {
            queue.push({
              type: row.type,
              name: row.name,
              fadeOut: row.fadeOut === 'true',
              fadeIn: row.fadeIn === 'true',
              autoplay: row.autoplay === 'true'
            });
          });
          renderQueue();
          alert(`Imported ${results.data.length} items.`);
          document.getElementById('import-csv').value = ""; // Reset file input
        },
        error: err => {
          alert('CSV parse error: ' + err.message);
          document.getElementById('import-csv').value = ""; // Reset file input
        }
      });
    }

    // Export CSV listener
    document.getElementById('export-csv-button').addEventListener('click', () => {
      if (!queue.length) return alert('Queue is empty');
      const headers=['type','name','fadeOut','fadeIn','autoplay'];
      const rows = queue.map(item => [item.type,item.name,item.fadeOut?'true':'false',item.fadeIn?'true':'false',item.autoplay?'true':'false']);
      const csv = [headers, ...rows].map(r=>r.join(',')).join('\n');
      const blob=new Blob([csv],{type:'text/csv'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download='queue.csv';
      document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    });

    function renderQueue() {
      queueEl.innerHTML = '';
      queue.forEach((item, i) => {
        const div = document.createElement('div');
        div.className = 'queue-tile' + (i === currentIdx ? ' current' : '');
        div.addEventListener('click', () => {
          currentIdx = i;
          renderQueue();
        });

        // Render the asset or transition tile
        if (item.type === 'slide') {
          const img = document.createElement('img');
          img.src = `/static/slides/${item.name}`;
          div.appendChild(img);
        } else if (item.type === 'video') {
          const vid = document.createElement('video');
          vid.muted = true;
          vid.src = `/static/media/${item.name}`;
          div.appendChild(vid);
        } else {
          let label = '';
          if (item.name === 'fade_to_black') label = 'Fade to Black';
          if (item.name === 'fade_from_black') label = 'Fade from Black';
          if (item.name === 'crossfade') label = 'Crossfade';
          if (item.name === 'autoplay_next') label = 'Autoplay Next';
          const div2 = document.createElement('div');
          div2.style.cssText = 'background:#000;width:100%;height:60px;display:flex;align-items:center;justify-content:center;';
          if (item.name === 'fade_from_black') div2.style.background = '#444';
          if (item.name === 'crossfade') div2.style.background = 'linear-gradient(90deg,#111,#fff,#111)';
          if (item.name === 'autoplay_next') div2.style.background = '#005bb5';
          div2.innerHTML = `<span class="transition-label" style="color:${item.name === 'crossfade' ? 'black' : 'white'}">${label}</span>`;
          div.appendChild(div2);
        }
        const lbl = document.createElement('div');
        lbl.className = 'tile-label';
        lbl.textContent = item.name;
        div.appendChild(lbl);

        const autoBtn = document.createElement('button');
          autoBtn.className = 'autoplay-toggle' + (item.autoplay ? ' on' : '');
          autoBtn.title = 'Toggle autoplay next for this video';
          autoBtn.textContent = 'Auto';
          autoBtn.onclick = function(ev) {
            ev.stopPropagation();
            item.autoplay = !item.autoplay;
            renderQueue();
          };
          div.appendChild(autoBtn);
        

        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-btn';
        removeBtn.innerHTML = '&times;';
        removeBtn.title = 'Remove from queue';
        removeBtn.onclick = function(ev) {
          ev.stopPropagation(); // Prevent queue selection
          // Remove the item
          queue.splice(i, 1);
          // Adjust currentIdx if needed
          if (currentIdx >= queue.length) currentIdx = queue.length - 1;
          renderQueue();
        };
        div.appendChild(removeBtn);

        queueEl.appendChild(div);
      });

      // ------ Preview logic (this is the important part) ------
      if (queue[currentIdx]) {
        let toPreview = queue[currentIdx];
        if (toPreview.type === 'transition') {
          let nonTrans = getFirstNonTransitionAfter(currentIdx);
          if (nonTrans) toPreview = nonTrans;
        }
        previewQueueItem(toPreview);
      }
    }

    // Queue navigation
    function nextInQueue() {
      if (!queue.length) return alert('Queue empty');
      currentIdx = (currentIdx + 1) % queue.length;
      renderQueue();
    }

    function prevInQueue() {
      if (!queue.length) return alert('Queue empty');
      currentIdx = (currentIdx - 1 + queue.length) % queue.length;
      renderQueue();
    }


    function step(delta){ socket.emit('change_slide',{index:delta}); }

    // Send asset
    let autoplayEnabled=false;
    function sendCurrent(){ if(currentIdx<0||currentIdx>=queue.length)return alert('Select asset first'); sendAsset(queue[currentIdx],currentIdx); }
    
    function sendAsset(asset, idx) {
      const fadeOut = document.getElementById('fadeout-checkbox').checked;
      const fadeIn = document.getElementById('fadein-checkbox').checked;
      // No longer need a global autoplay checkbox for videos, but can keep if you want manual override
      // const autoplay = document.getElementById('autoplay-checkbox').checked;

      // --- FADE TO BLACK ---
      if (asset.type === 'transition' && asset.name === 'fade_to_black') {
        const dur = parseFloat(document.getElementById('fade-black-duration')?.value) || 0.8;
        socket.emit('fade_to_black', { duration: dur });
        return;
      }

      // --- FADE FROM BLACK ---
      if (asset.type === 'transition' && asset.name === 'fade_from_black') {
        // Find next non-transition asset in queue for fade-up!
        let nextIdx = (idx + 1) % queue.length;
        let nextAsset = null;
        for (let tries = 0; tries < queue.length; tries++) {
          if (queue[nextIdx].type !== 'transition') {
            nextAsset = queue[nextIdx];
            break;
          }
          nextIdx = (nextIdx + 1) % queue.length;
        }
        const dur = parseFloat(document.getElementById('fade-black-duration')?.value) || 0.8;
        if (nextAsset) {
          // 1. Switch the asset under black
          socket.emit('display_asset', { ...nextAsset });

          // 2. Move highlight to the new asset and re-render
          currentIdx = nextIdx;
          renderQueue();

          // 3. After a very short delay, fade up from black
          setTimeout(() => {
            socket.emit('fade_from_black', { duration: dur });
          }, 20);
        }
        return;
      }

      // --- CROSSFADE ---
      if (asset.type === 'transition' && asset.name === 'crossfade') {
        const nextIdx = (idx + 1) % queue.length;
        const nextAsset = queue[nextIdx];

        if (nextAsset && (nextAsset.type === 'slide' || nextAsset.type === 'video')) {
          currentIdx = nextIdx;
          renderQueue();

          const dur = parseFloat(document.getElementById('crossfade-duration').value) || 2.0;

          socket.emit('crossfade_to', {
            ...nextAsset,
            crossfade_duration: dur
          });
          updatePreviewArea(nextAsset);
        }
        return;
      }

      // --- DISPLAY SLIDE OR VIDEO (default case) ---
      if (fadeOut) {
        const dur = parseFloat(document.getElementById('fade-black-duration')?.value) || 0.8;
        socket.emit('fade_to_black', { duration: dur });
        setTimeout(() => {
          socket.emit('display_asset', { ...asset, fadeIn, autoplay: !!asset.autoplay });
          updatePreviewArea(asset);
          // Only setupAutoplayListener for video assets
          if (asset.type === 'video') setupAutoplayListener();
        }, dur * 1000 + 20);
      } else {
        socket.emit('display_asset', { ...asset, fadeIn, autoplay: !!asset.autoplay });
        updatePreviewArea(asset);
        if (asset.type === 'video') setupAutoplayListener();
      }
    }

    function setupAutoplayListener() {
      const video = document.getElementById('current-audience-video');
      video.onended = function() {
        // Check if the current video has autoplay enabled
        if (queue[currentIdx] && queue[currentIdx].type === 'video' && queue[currentIdx].autoplay) {
          // Advance to next in queue (could be transition, fade, etc.)
          let ni = (currentIdx + 1) % queue.length;
          let next = queue[ni];
          if (next) {
            currentIdx = ni;
            renderQueue();
            sendAsset(next, currentIdx);
          }
        } else {
          // No autoplay: do nothing, just pause at end.
          video.onended = null;
        }
      };
    }

    // Preview
    function previewQueueItem(item){ if(item.type==='slide'){ previewImg.style.display='block'; previewImg.src=`/static/slides/${item.name}`; previewVid.style.display='none'; } else if(item.type==='video'){ previewVid.style.display='block'; previewSrc.src=`/static/media/${item.name}`; previewVid.load(); previewImg.style.display='none'; } else { previewImg.style.display='none'; previewVid.style.display='none'; }}

    // Audience reflection
    socket.on('sync_state',updateAudiencePanel);
    socket.on('viewer_count_update', data => {
      console.log('Viewer count updated:', data);
      document.getElementById('viewer-count').textContent = data.count;
    });
    socket.on('display_asset',updateAudiencePanel);
    socket.on('play_pause_video',updateAudiencePanel);
    socket.on('set_playback_speed',asset=>updateAudiencePanel(asset));
    socket.on('seek_video',({time})=>updateAudiencePanel({video_time:time}));
    socket.on('crossfade_to', updateAudiencePanel);
    
    socket.on('fade_to_black', function(data) {
      const c = document.getElementById('current-audience-container');
      c.style.background = 'black';
      document.getElementById('current-audience-img').style.display = 'none';
      document.getElementById('current-audience-video').style.display = 'none';
    });
    socket.on('fade_from_black', function(data) {
      document.getElementById('current-audience-container').style.background = '';
    });
    function updateAudiencePanel(asset) {
        if (!asset) return;
        const ci = document.getElementById('current-audience-img');
        const cv = document.getElementById('current-audience-video');
        const cs = document.getElementById('current-audience-source');

        if (asset.type === 'slide') {
            cv.style.display = 'none';
            ci.src = `/static/slides/${asset.name}`;
            ci.style.display = 'block';
        } else if (asset.type === 'video') {
            ci.style.display = 'none';
            cs.src = `/static/media/${asset.name}`;
            cv.load();
            cv.style.display = 'block';
            cv.muted = true;

            cv.onloadedmetadata = function () {
                cv.currentTime = asset.video_time || 0;
                cv.playbackRate = asset.video_speed || 1.0;
                if (!asset.video_paused || asset.autoplay) {
                    cv.play().catch(() => { });
                } else {
                    cv.pause();
                }
            };
        }
    }

    //Add this new function to update the preview
    function updatePreviewArea(asset){
        socket.emit('sync_state',asset)
    }

    function getFirstNonTransitionAfter(idx) {
      if (!queue.length) return null;
      let i = (idx + 1) % queue.length;
      for (let tries = 0; tries < queue.length; tries++) {
        if (queue[i].type !== 'transition') return queue[i];
        i = (i + 1) % queue.length;
      }
      return null;
    }

    // Sortable
    new Sortable(queueEl,{ animation:150,onEnd(evt){ const t=queue[evt.oldIndex]; queue.splice(evt.oldIndex,1); queue.splice(evt.newIndex,0,t); if(currentIdx===evt.oldIndex) currentIdx=evt.newIndex; else if(evt.oldIndex<currentIdx&&evt.newIndex>=currentIdx) currentIdx--; else if(evt.oldIndex>currentIdx&&evt.newIndex<=currentIdx) currentIdx++; renderQueue(); }});

    

    // Keyboard & init
    const playPauseBtn=document.getElementById('play-pause-button');
    document.addEventListener('keydown',e=>{
      if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;

      if(e.key==='ArrowRight'){
        nextInQueue();
        e.preventDefault();
      } else if(e.key==='ArrowLeft'){
        prevInQueue();
        e.preventDefault();
      } else if(e.key==='Enter'){
        sendCurrent();
        e.preventDefault();
      } else if (e.key === 'ArrowUp') { // New: Up Arrow (modified)
          let newIndex = currentIdx;
          // Find the previous non-transition asset
          while (newIndex > 0) {
              newIndex--;
              if (queue[newIndex].type !== 'transition') {
                  currentIdx = newIndex;
                  break;
              }
          }
          if (queue[currentIdx].type === 'transition') {
              // If no non-transition asset found, stay at current index
              newIndex = currentIdx;
              currentIdx = newIndex;
          }

          renderQueue();
          sendCurrent();
          e.preventDefault();
      }  else if (e.key === 'ArrowDown') { // New: Down Arrow
        nextInQueue();
        sendCurrent();
        e.preventDefault();
      } else if(e.code==='Space'){
        playPauseBtn.click();
        e.preventDefault();
      }
    });
    playPauseBtn.onclick=()=>{ const v=document.getElementById('current-audience-video'); if(v.style.display==='block'){ v.paused?v.play():v.pause(); } socket.emit('play_pause_video'); };
    const crossfadeInput=document.getElementById('crossfade-duration'); if(localStorage.getItem('crossfade_duration')) crossfadeInput.value=localStorage.getItem('crossfade_duration'); crossfadeInput.onchange=()=>localStorage.setItem('crossfade_duration',crossfadeInput.value);
    renderQueue();

      //Emit sync state
    socket.emit('sync_state', { type: 'slide', name: 'holdingslide.jpg', autoplay: false, fadeIn: false });

  </script>
</body>
</html>